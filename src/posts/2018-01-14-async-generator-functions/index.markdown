---
path: "/async-generator-functions"
published: false
title: "Async Generator Functions"
date: "2018-01-14"
tags: ["async", "generator", "functions", "iterator", "yield", "for-await-of", "for", "await", "of"]
---
An exciting new feature of js is async generator functions. A normal function in javascript is
run from beginning till end i.e. run to completion. Once invoked, the entire body
of the function is executed until the end is reached. You can't stop or pause the execution of an
ordinary js function.

Generator functions however, does not run to completion. You use the yield keyword to pause function
execution and then the next() method to continue execution.



## Goal
Use async generator functions right now with babel.

## Step 1: What is a generator function?
A generator function is a function which returns an iterator when run.
An iterator is an object that has a next() method implemented returning an object { value, done }.

{% highlight javascript %}
function* () {
    console.log(1);
    let temp = yield "first yield";
    console.log(temp);
    yield "second yield";
    return;
} 
{% endhighlight %}

## Step 2: What is an async generator function?
Is the same as a generator function, BUT iterator.next() returns a promise returning the { value, done } object.

{% highlight javascript %}
async function* () {
    console.log(1);
    let temp = yield "first yield";
    console.log(temp);
    yield "second yield";
    return;
} 
{% endhighlight %}

## Step 3: How to use async generator with babel
{% highlight bash %}
yarn add --dev babel-plugin-transform-async-to-generator babel-plugin-transform-async-generator-functions
{% endhighlight %}

Then in your .babelrc file:

{% highlight json %}
{
  "plugins": [
    "transform-async-to-generator",
    "transform-async-generator-functions"
  ]
}
{% endhighlight %}


Install relay-compiler-plus and the latest [graphql-js](https://github.com/graphql/graphql-js){:target="_blank"} package:

{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}

{% highlight bash %}
yarn upgrade graphql --latest
{% endhighlight %}

## Step 2: Compile
Add this npm command to your **package.json**:

{% highlight json %}
"scripts": {
    "rcp": "relay-compiler-plus --schema <SCHEMA_FILE_PATH> --src <SRC_DIR_PATH> -f"
},
{% endhighlight %}
    
where:<br/> 
`<SCHEMA_FILE_PATH>` is the path to your schema.graphql or schema.json file<br/>
`<SRC_DIR_PATH>` is the path to your src directory<br/>
`-f` will delete all `**/__generated__/*.graphql.js` files under `SRC_DIR_PATH` before compilation starts<br/>

Run the command to start compiling:

{% highlight bash %}
npm run rcp
{% endhighlight %}

## Step 3: Map query ids on the server
On the server, use `matchQueryMiddleware` prior to `express-graphql` to match query ids to actual queries. Note 
that `queryMap.json` is auto-generated by `relay-compiler-plus` in the previous step.

{% highlight javascript %}
import Express from 'express';
import expressGraphl from 'express-graphql';
import {matchQueryMiddleware} from 'relay-compiler-plus'; // do this
import queryMapJson from '../queryMap.json'; // do this

const app = Express();

app.use('/graphql',
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}

## Step 4: Send query ids on the client
On the client, modify your relay network fetch implementation to pass a `queryId` parameter in the
request body instead of a `query` parameter. Note that `operation.id` is generated by `relay-compiler-plus` in step 2.

{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch('/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response => {
    return response.json();
  });
}
{% endhighlight %}

## Bonus
In [step 2](#step-2-compile), running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated `ConcreteBatch` query file and you'll see that it now has an `id` assigned 
to it and that the query `text` is now `null`:

{% highlight javascript %}
const batch /*: ConcreteBatch*/ = {
  "fragment": {
    "argumentDefinitions": [],
    "kind": "Fragment",
    "metadata": null,
    "name": "client_index_Query",
    "selections": [...],
    "type": "Query"
  },
  "id": "6082095e8a45f64d38924775d047cf8c", // look ma, query id!
  "kind": "Batch",
  "metadata": {},
  "name": "client_index_Query",
  "query": {...},
  "text": null // look again ma, null query text!
};
{% endhighlight %}

The id is an md5 hash of the query text, generated by the [persistQuery](https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js){:target="_blank"} 
function. It looks like this:

{% highlight javascript %}
 function persistQuery(operationText: string): Promise<string> {
   return new Promise((resolve) => {
     const queryId = md5(operationText);
     
     // queryCache is written to disk at the end as queryMap.json
     queryCache.push({id: queryId, text: operationText});
     resolve(queryId);
   });
 }   
{% endhighlight %}

As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
[step 3](#step-3-map-query-ids-on-the-server).

## Conclusion
You can find the package at [github](https://github.com/yusinto/relay-compiler-plus){:target="_blank"} with a fully working
[example](https://github.com/yusinto/relay-compiler-plus/tree/master/example){:target="_blank"}. 

Let me know if this is useful (or not)! 

---------------------------------------------------------------------------------------
