---
path: "/relay-modern-persisted-queries"
date: "2018-01-09 07:30"
title: "Relay Modern Server Side Rendering"
published: false
tags: ["relay", "modern", "ssr", "server", "side", "rendering", "redux"]
---
Relay modern is awesome, but unfortunately not much has been documented about how to use it with ssr. Facebook
does not use ssr with relay modern so it's up to the community to do something about it. When I say community it's
really just one man Jimmy Chia aka taion who has single-handedly written found router, farce and found relay to
make ssr possible with relay modern.

If you are using react-router, you're out of luck. You'll need to jump the cliff and swap it out with found. I have 
done it and I never look back. Found is very similar to react router v3, so you won't have any problems switching.

## Goal
Create a relay modern app with ssr with found and found relay.

## Step 1: Install npm packages
Install babel-polyfill (for async await), found and found relay

## Step 2: Create routes
create routes, makeRouteConfig, export that routeConfig object.
createBrowserRouter using routeConfig object.

## Step 3: SSR
use the same routes object
on the client bootstrap use createInitialBrowserRouter instead and await on that
u also need createRender function (TODO: investigate why?) 

On the server, await getFarceResult from found/lib/server passing in url, routeConfig and 
render method to get the output data from the requested route.

Then renderToString the element property from the output. That's it!

Without redux, it's soo much cleaner! 

Install relay-compiler-plus and the latest [graphql-js](https://github.com/graphql/graphql-js){:target="_blank"} package:

```bash
yarn add relay-compiler-plus
```

```bash
yarn upgrade graphql --latest
```

## Step 2: Compile
Add this npm command to your **package.json**:

```json
"scripts": {
    "rcp": "relay-compiler-plus --schema <SCHEMA_FILE_PATH> --src <SRC_DIR_PATH> -f"
},
```
    
where:<br/> 
`<SCHEMA_FILE_PATH>` is the path to your schema.graphql or schema.json file<br/>
`<SRC_DIR_PATH>` is the path to your src directory<br/>
`-f` will delete all `**/__generated__/*.graphql.js` files under `SRC_DIR_PATH` before compilation starts<br/>

Run the command to start compiling:

```bash
npm run rcp
```

## Step 3: Map query ids on the server
On the server, use `matchQueryMiddleware` prior to `express-graphql` to match query ids to actual queries. Note 
that `queryMap.json` is auto-generated by `relay-compiler-plus` in the previous step.

```js
import Express from 'express';
import expressGraphl from 'express-graphql';
import {matchQueryMiddleware} from 'relay-compiler-plus'; // do this
import queryMapJson from '../queryMap.json'; // do this

const app = Express();

app.use('/graphql',
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
```

## Step 4: Send query ids on the client
On the client, modify your relay network fetch implementation to pass a `queryId` parameter in the
request body instead of a `query` parameter. Note that `operation.id` is generated by `relay-compiler-plus` in step 2.

```js
function fetchQuery(operation, variables,) {
  return fetch('/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response => {
    return response.json();
  });
}
```

## Bonus
In [step 2](#step-2-compile), running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated `ConcreteBatch` query file and you'll see that it now has an `id` assigned 
to it and that the query `text` is now `null`:

```js
const batch /*: ConcreteBatch*/ = {
  "fragment": {
    "argumentDefinitions": [],
    "kind": "Fragment",
    "metadata": null,
    "name": "client_index_Query",
    "selections": [...],
    "type": "Query"
  },
  "id": "6082095e8a45f64d38924775d047cf8c", // look ma, query id!
  "kind": "Batch",
  "metadata": {},
  "name": "client_index_Query",
  "query": {...},
  "text": null // look again ma, null query text!
};
```

The id is an md5 hash of the query text, generated by the [persistQuery](https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js){:target="_blank"} 
function. It looks like this:

```js
 function persistQuery(operationText: string): Promise<string> {
   return new Promise((resolve) => {
     const queryId = md5(operationText);
     
     // queryCache is written to disk at the end as queryMap.json
     queryCache.push({id: queryId, text: operationText});
     resolve(queryId);
   });
 }   
```

As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
[step 3](#step-3-map-query-ids-on-the-server).

## Conclusion
You can find the package at [github](https://github.com/yusinto/relay-compiler-plus){:target="_blank"} with a fully working
[example](https://github.com/yusinto/relay-compiler-plus/tree/master/example){:target="_blank"}. 

Let me know if this is useful (or not)! 

---------------------------------------------------------------------------------------
