---
path: "/relay-modern-persisted-queries"
date: "2017-11-12"
title: "Relay Modern Persisted Queries"
published: true
tags: ["relay", "modern", "persisted", "queries", "graphql", "javascript", "js"]
---
This blog is about [relay-compiler-plus](https://github.com/yusinto/relay-compiler-plus), 
a custom relay compiler which supports persisted queries.

One of the more exciting features of relay modern is the ability to use persisted queries with the graphql server.
Instead of sending the full graphql query in the request payload, you send a short query id which gets mapped
on the server side to the full query. It's a no-brainer for performance. I upgraded from classic for this! 

Alas, the official [documentation](https://facebook.github.io/relay/docs/new-in-relay-modern.html)
only briefly mentioned this without anything else. A quick google search reveals a solution from 
[Scott Taylor](https://medium.com/@wonderboymusic/upgrading-to-relay-modern-or-apollo-ffa58d3a5d59)
from the New York Times. However his solution generates query ids at runtime at the network fetch level which is not
optimal. I want a solution where the query ids and the query map file are both generated at compile time for maximum
performance.

It turns out, the original relay-compiler does have a hidden feature to support persisted queries.  

This package is inspired by a conversation with [Lee Byron](https://github.com/leebyron) 
at [Graphql Summit 2017](https://summit.graphql.com/).

## The key
The key lies in [RelayFileWriter](https://github.com/facebook/relay/blob/master/packages/relay-compiler/codegen/RelayFileWriter.js).
It accepts a config object where you can specify a persistQuery function. You can dig around and peruse
that code at your leisure (which I did). The end result is a modification to the relay-compiler which
accepts a persistQuery function which gets passed down to RelayFileWriter. I call it 
[relay-compiler-plus](https://github.com/yusinto/relay-compiler-plus). 

## Step 1: Install
Install relay-compiler-plus and the latest [graphql-js](https://github.com/graphql/graphql-js) package:

```bash
yarn add relay-compiler-plus
```

```bash
yarn upgrade graphql --latest
```

## Step 2: Compile
Add this npm command to your **package.json**:

```json
"scripts": {
    "rcp": "relay-compiler-plus --schema <SCHEMA_FILE_PATH> --src <SRC_DIR_PATH> -f"
},
```
    
where:<br/> 
*SCHEMA\_FILE\_PATH* is the path to your schema.graphql or schema.json file<br/>
*SRC\_DIR\_PATH* is the path to your src directory<br/>
*-f* will delete all \*\*/\_\_generated\_\_/\*.graphql.js files under *SRC\_DIR\_PATH* before compilation starts.<br/>

Run the command to start compiling:

```bash
npm run rcp
```

## Step 3: Map query ids on the server
On the server, use *matchQueryMiddleware* prior to *express-graphql* to match query ids to actual queries. Note 
that *queryMap.json* is auto-generated by *relay-compiler-plus* in the previous step.

```jsx{3-4,9}
import Express from 'express';
import expressGraphl from 'express-graphql';
import {matchQueryMiddleware} from 'relay-compiler-plus'; // do this
import queryMapJson from '../queryMap.json'; // do this

const app = Express();

app.use('/graphql',
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
```

## Step 4: Send query ids on the client
On the client, modify your relay network fetch implementation to pass a queryId parameter in the
request body instead of a query parameter. Note that operation.id is generated by relay-compiler-plus in step 2.

```jsx{8}
function fetchQuery(operation, variables,) {
  return fetch('/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response => {
    return response.json();
  });
}
```

## Bonus
In [step 2](#step-2-compile), running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated ConcreteBatch query file and you'll see that it now has an id assigned 
to it and that the query text is now null:

```jsx
const batch /*: ConcreteBatch*/ = {
  "fragment": {
    "argumentDefinitions": [],
    "kind": "Fragment",
    "metadata": null,
    "name": "client_index_Query",
    "selections": [...],
    "type": "Query"
  },
  "id": "6082095e8a45f64d38924775d047cf8c", // look ma, query id!
  "kind": "Batch",
  "metadata": {},
  "name": "client_index_Query",
  "query": {...},
  "text": null // look again ma, null query text!
};
```

The id is an md5 hash of the query text, generated by the [persistQuery](https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js) 
function. It looks like this:

```jsx
 function persistQuery(operationText: string): Promise<string> {
   return new Promise((resolve) => {
     const queryId = md5(operationText);
     
     // queryCache is written to disk at the end as queryMap.json
     queryCache.push({id: queryId, text: operationText});
     resolve(queryId);
   });
 }   
```

As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
[step 3](#step-3-map-query-ids-on-the-server).

## Conclusion
You can find the package at [github](https://github.com/yusinto/relay-compiler-plus) with a fully working
[example](https://github.com/yusinto/relay-compiler-plus/tree/master/example). 

Let me know if this is useful (or not)! 

---------------------------------------------------------------------------------------
